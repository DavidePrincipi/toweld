#!/usr/bin/env python2.7

#
# Copyright (C) 2017 Nethesis S.r.l.
# http://www.nethesis.it - nethserver@nethesis.it
#
# This script is part of NethServer.
#
# NethServer is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License,
# or any later version.
#
# NethServer is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with NethServer.  If not, see COPYING.
#

import dbus
import dbus.service
import glib
import dbus.glib
import os
import logging
import traceback

logging.basicConfig(level=logging.INFO)

class Toweld(dbus.service.Object):
    def __init__(self):
        self.plugins = []
        self.loop = glib.MainLoop()
        self.bus_name = dbus.service.BusName('org.nethserver.toweld1', bus = dbus.SystemBus())
        super(Toweld, self).__init__(self.bus_name, '/org/nethserver/toweld1/Toweld')

    # This method never returns until a "stop" message is received
    def run(self):
        self.load_plugins()
        
        
        self.to = 0
        
        def timeout_handler():
             
            self.to += 1
            logging.debug('Timeout %d' % self.to)
            
            if self.to >= 0:
                return False
            
            return True

        glib.timeout_add(3000, timeout_handler)
        self.loop.run()

    def load_plugins(self):
        plugins = self.plugins
        conn = self.connection
        path_prefix = '/org/nethserver/toweld1/'
        for filename in os.listdir('/etc/nethserver/toweld/plugins'):
            if filename.endswith('.py'):
                logging.debug('Instantiating plugin from "%s"' % filename)
                try:
                    execfile('/etc/nethserver/toweld/plugins/%s' % filename)
                except Exception as e:
                    logging.exception('Plugin %s failed to load' % filename)

        logging.info('Loaded plugins list: %s' % ', '.join(map((lambda o: o.__class__.__name__), self.plugins)))


    @dbus.service.method('org.nethserver.toweld1.Toweld')
    def Stop(self):
        del self.plugins
        self.loop.quit()

    @dbus.service.method('org.nethserver.toweld1.Toweld', in_signature='sas', out_signature='i', async_callbacks=('on_success', 'on_error'))
    def Validate(self, validator, args, on_success, on_error):
        def fdready(fd, condition):
            logging.debug('fd %s, condition %s' % (fd, condition))
            if condition & (glib.IO_IN | glib.IO_PRI):
                buf = ''
                while True:
                    data = os.read(fd, 1024)
                    buf += data
                    if len(data) < 1024 or len(buf) > 20000:
                        break

                logging.debug(buf)
            
            if condition & glib.IO_HUP:
                return False
                
            return True

        execv = ['/sbin/e-smith/validate', str(validator)]
        execv.extend([str(s) for s in args])
        (pid, fdin, fdout, fderr) = glib.spawn_async(execv, standard_output=False, standard_error=False, flags=glib.SPAWN_DO_NOT_REAP_CHILD)
        glib.child_watch_add(pid, lambda pid, cond: on_success(int(cond >> 8)))
        #glib.io_add_watch(fdout, glib.IO_IN | glib.IO_OUT | glib.IO_PRI | glib.IO_ERR | glib.IO_HUP, fdready )

    @dbus.service.method('org.nethserver.toweld1.Toweld')
    def Spawn(self):
        def fdready(fd, condition):
            logging.debug('fd %s, condition %s' % (fd, condition))
            if condition & (glib.IO_IN | glib.IO_PRI):
                buf = ''
                while True:
                    data = os.read(fd, 1024)
                    buf += data
                    if len(data) < 1024 or len(buf) > 20000:
                        break
                        
                logging.debug(buf)
            
            if condition & glib.IO_HUP:
                return False
                
            return True

        (pid, fdin, fdout, fderr) = glib.spawn_async(['/usr/bin/cat', 'test invocation toweld'], standard_output=True)
        glib.io_add_watch(fdout, glib.IO_IN | glib.IO_OUT | glib.IO_PRI | glib.IO_ERR | glib.IO_HUP, fdready )
        logging.debug('Pid %s spawned' % pid)


Toweld().run()
